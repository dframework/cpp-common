#ifndef _WIN32
#include <dframework/base/ThreadManager.h>
#include <dframework/fscore/FuseWorker.h>
#include <dframework/fscore/FuseUtil.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <sys/time.h>

#define PARAM(inarg) (((char *)(inarg)) + sizeof(*(inarg)))

#define DFW_FUSEWORKER_E(retval,req,err)               \
    (!!(retval->error()                            \
    ? req->send_error(retval->error())             \
    : req->send_error(err)))                       \
    ?  DFW_RETVAL_D(retval) : DFW_RETVAL_D(retval)

namespace dframework {

    FuseWorker::FuseWorker(){
        ::memset(m_opcodes, 0, FUSE::OP_MAX);
    }

    FuseWorker::~FuseWorker(){
    }

    sp<Retval> FuseWorker::do_init(sp<FuseRequest>& req){
        sp<Retval> retval;
        sp<FsNode> node = req->m_nl->makeFolder("/", 1, 0);

        if( DFW_RET(retval, req->m_nl->insertNode(node)) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);

        if( is_enable(FUSE::OP_INIT) ){
            if( DFW_RET(retval, on_init(req)) )
                return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::do_getattr(sp<FuseRequest>& req){
        sp<Retval> retval;
        sp<FsNode> node;/*, parent;*/
        String fpath;
        const char* fullpath = NULL;

        if( !is_enable(FUSE::OP_GETATTR) )
            return DFW_RET_C(retval, req->send_error(-ENOSYS));

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        struct stat st;
        ::memset(&st, 0, sizeof(st));

        if(DFW_RET(retval, on_getattr(req, fullpath, &st))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        struct fuse_attr_out arg;
        size_t size = req->proto_minor() < 9 ?
                FUSE_COMPAT_ATTR_OUT_SIZE : sizeof(arg);

        ::memset(&arg, 0, sizeof(arg));
        arg.attr_valid = 1; //FIXME:calc_timeout_sec(attr_timeout);
        arg.attr_valid_nsec = 0; //FIXME:calc_timeout_nsec(attr_timeout);
        FuseUtil::statToFuse(&arg.attr, &st);

        ::memcpy(&node->m_stat, &st, sizeof(st));

        return DFW_RET_C(retval, req->send_ok(&arg, size));
    }

    sp<Retval> FuseWorker::do_opendir(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_open_in* in = (struct fuse_open_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        if(!is_enable(FUSE::OP_OPENDIR) && !is_enable(FUSE::OP_READDIR))
            return DFW_RET_C(retval, req->send_error(-ENOSYS));

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        struct fuse_open_out arg;
        ::memset(&arg, 0, sizeof(arg));

        sp<FuseDirCtx> ctx = new FuseDirCtx();
        ctx->m_flags = in->flags;

        if( is_enable(FUSE::OP_OPENDIR) &&
              DFW_RET(retval, on_opendir(req, fullpath, ctx))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        arg.fh = (uint64_t)sp<FuseDirCtx>::undocking(ctx.get());

        if( DFW_RET(retval, req->send_ok(&arg, sizeof(arg))) ){
            if( retval->error()==ENOENT ){
                if( is_enable(FUSE::OP_RELEASEDIR) )
                    on_releasedir(req, fullpath, ctx);
            }
            sp<FuseDirCtx>::docking(ctx.get());
            return DFW_RETVAL_D(retval);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::do_readdir(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_read_in* in = (struct fuse_read_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        if( !is_enable(FUSE::OP_READDIR) )
            return DFW_RET_C(retval, req->send_error(-ENOSYS));

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        sp<FuseDirCtx> ctx = (FuseDirCtx*)in->fh;
        if(!ctx.has()){
            retval = DFW_RETVAL_NEW_MSG(DFW_ERROR, -EIO
                          , "nodeid=%ld, Not find FsUserDir."
                          , req->nodeid());
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        if(in->size && !in->offset && !ctx->isFilled()){
          if(DFW_RET(retval, on_readdir(req, fullpath, ctx)))
              return DFW_FUSEWORKER_E(retval,req,-EIO);
          ctx->setFilled();
        }

        size_t size = in->size;
        if( in->offset >= ctx->length() ){
            size = 0;
        }else if( (in->offset+in->size) > ctx->length()){
            size = ctx->length() - in->offset;
        }

        if(DFW_RET(retval, req->send_ok(
                                   ctx->getBuffer(in->offset), size))){
            return DFW_RETVAL_D(retval);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::do_releasedir(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_release_in* in 
                                = (struct fuse_release_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        sp<FuseDirCtx> ctx = (FuseDirCtx*) in->fh;
        if(in->fh)
            sp<FuseDirCtx>::docking((FuseDirCtx*)in->fh);

        if( !is_enable(FUSE::OP_RELEASEDIR) ) // TODO: No error.
            return DFW_RET_C(retval, req->send_error(0));

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        if(DFW_RET(retval, on_releasedir(req, fullpath, ctx))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        return DFW_RET_C(retval, req->send_error(0));
    }

    sp<Retval> FuseWorker::do_lookup(sp<FuseRequest>& req){
        sp<Retval> retval;
        sp<FsNode> node, parent;
        String fpath;
        const char* fullpath = NULL;
        const char* name = (const char*)req->arg();
        int isready = 0;
        struct stat st;
        int lookup_type;

        while(true){
            if( DFW_RET(retval, req->m_nl->makeLookupNode(node, fpath
                                    , &isready, req->nodeid(), name)) )
                return DFW_FUSEWORKER_E(retval,req,-EIO);
            lookup_type = node->getType();
            if(lookup_type==FsNode::DFW_FSNODE_TYPE_READY && !isready){
                req->m_nl->lookup_wait(node);
                continue;
            }
            break;
        }
        fullpath = fpath.toChars();
        parent = req->m_nl->_findNode(node->m_parentid);

        if( is_enable(FUSE::OP_LOOKUP) ){
            if(DFW_RET(retval, on_lookup(req,fullpath, &st))){
                req->m_nl->resultLookupNode(node, false);
                return DFW_FUSEWORKER_E(retval,req,-EIO);
            }
        }else if( is_enable(FUSE::OP_GETATTR) ){
            if(DFW_RET(retval, on_getattr(req,fullpath,&st))){
                req->m_nl->resultLookupNode(node, false);
                return DFW_FUSEWORKER_E(retval,req,-EIO);
            }
        }else{
            return DFW_RET_C(retval, req->send_error(-ENOSYS));
        }

        struct fuse_entry_param entry;
        ::memset(&entry, 0, sizeof(entry));
        entry.generation = req->m_nl->generation();
        entry.entry_timeout = 1.0;
        entry.attr_timeout  = 1.0;
        ::memcpy(&entry.attr, &st, sizeof(struct stat));
        {
            ::memcpy(&node->m_stat, &st, sizeof(struct stat));
            if(lookup_type==FsNode::DFW_FSNODE_TYPE_READY)
                req->m_nl->resultLookupNode(node, true);
        }
        entry.ino = node->m_nodeid;

        if( DFW_RET(retval, req->send_entry(&entry)) ){
            return DFW_RETVAL_D(retval);
        }
        return NULL;
    }

    sp<Retval> FuseWorker::do_open(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_open_in* in = (struct fuse_open_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        if( !is_enable(FUSE::OP_OPEN) 
                  && !is_enable(FUSE::OP_READ) ){
            retval = DFW_RETVAL_NEW_MSG(DFW_ERROR, 0
                      , "nodeid=%ld, Not enable open or read function."
                      , req->nodeid());
            return DFW_FUSEWORKER_E(retval,req,-ENOSYS);
        }

        struct fuse_open_out arg;
        ::memset(&arg, 0, sizeof(arg));

        sp<FuseOpenCtx> ctx = new FuseOpenCtx();
        ctx->m_flags = in->flags;

        if( is_enable(FUSE::OP_OPEN) 
                  && DFW_RET(retval, on_open(req,fullpath, ctx))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

#if 0
        if(ctx->m_direct_io)   arg.open_flags |= FOPEN_DIRECT_IO;
        if(ctx->m_keep_cache)  arg.open_flags |= FOPEN_KEEP_CACHE;
        if(ctx->m_nonseekable) arg.open_flags |= FOPEN_NONSEEKABLE;
#else
        //arg.open_flags |= FOPEN_DIRECT_IO;
        //arg.open_flags |= FOPEN_KEEP_CACHE;
        //if(ctx->m_nonseekable) arg.open_flags |= FOPEN_NONSEEKABLE;
#endif
        arg.fh = (uint64_t)sp<FuseOpenCtx>::undocking(ctx.get());

        if( DFW_RET(retval, req->send_ok(&arg, sizeof(arg))) ){
            if( retval->error()==ENOENT ){
                if( is_enable(FUSE::OP_RELEASE) )
                    on_release(req, fullpath, ctx);
            }
            sp<FuseOpenCtx>::docking(ctx.get());
            return DFW_RETVAL_D(retval);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::do_flush(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_flush_in* in = (struct fuse_flush_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        if( !is_enable(FUSE::OP_FLUSH) ){
            if( DFW_RET(retval, req->send_ok()) ){
                // FIXME:
            }
            return NULL;
            //return DFW_RET_C(retval, req->send_error(-ENOSYS));
        }

        sp<FuseOpenCtx> ctx = (FuseOpenCtx*)in->fh;
        if(!ctx.has()){
            retval = DFW_RETVAL_NEW_MSG(DFW_ERROR, -EIO
                          , "nodeid=%ld, Not find FuseOpenCtx."
                          , req->nodeid());
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        if(DFW_RET(retval, on_flush(req, fullpath, ctx))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::do_read(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_read_in* in = (struct fuse_read_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath = NULL;

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        if( !is_enable(FUSE::OP_READ) ){
            return DFW_RET_C(retval, req->send_error(-ENOSYS));
        }

        char buf[in->size];
        sp<FuseOpenCtx> ctx = (FuseOpenCtx*)in->fh;
        if(!ctx.has()){
            retval = DFW_RETVAL_NEW_MSG(DFW_ERROR, -EIO
                          , "nodeid=%ld, Not find FuseOpenCtx."
                          , req->nodeid());
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        unsigned out_size = 0;
        if(DFW_RET(retval, on_read(req, fullpath, &out_size
                               , buf, in->size, in->offset, ctx))){
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        if(DFW_RET(retval, req->send_ok(buf, out_size)))
            return DFW_RETVAL_D(retval);
        return NULL;
    }

    sp<Retval> FuseWorker::do_write(sp<FuseRequest>& req){
        sp<Retval> retval;
        return DFW_RET_C(retval, req->send_error(-ENOSYS));
    }

    sp<Retval> FuseWorker::do_release(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_release_in* in = (struct fuse_release_in*)req->arg();
        sp<FsNode> node;
        String fpath;
        const char* fullpath;

        sp<FuseOpenCtx> ctx;
        if(in->fh)
            ctx = sp<FuseOpenCtx>::docking((FuseOpenCtx*)in->fh);

        if( DFW_RET(retval, req->m_nl->getNode(node, fpath, req->nodeid())) )
            return DFW_FUSEWORKER_E(retval,req,-EIO);
        fullpath = fpath.toChars();

        if( is_enable(FUSE::OP_RELEASE) ){
            if(DFW_RET(retval, on_release(req, fullpath, ctx)))
                return DFW_FUSEWORKER_E(retval,req,-EIO);
        }

        return DFW_RET_C(retval, req->send_error(0));
    }

    /** Not response. */
    sp<Retval> FuseWorker::do_forget(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_forget_in *in = (struct fuse_forget_in *)req->arg();
        uint64_t nlookup = in->nlookup;

        if( is_enable(FUSE::OP_FORGET)
            && DFW_RET(retval, on_forget(req, req->nodeid(), nlookup))){
        }

        req->m_nl->forget(req->nodeid(), nlookup);

        return NULL;
    }

    /** Not response. */
    sp<Retval> FuseWorker::do_batchforget(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_batch_forget_in *in
                         = (struct fuse_batch_forget_in*)req->arg();
        struct fuse_forget_one *param
                         = (struct fuse_forget_one*) PARAM(in);

        if( is_enable(FUSE::OP_BATCH_FORGET)
                && DFW_RET(retval, on_batchforget(req))){
        }

        for(int i = 0; i < in->count; i++) {
            struct fuse_forget_one *forget = &param[i];
            req->m_nl->forget(forget->nodeid, forget->nlookup);
        }

        return NULL;
    }

    /** Not response. */
    sp<Retval> FuseWorker::do_interrupt(sp<FuseRequest>& req){
        sp<Retval> retval;
        struct fuse_interrupt_in *in
                             = (struct fuse_interrupt_in *)req->arg();

        if(is_enable(FUSE::OP_INTERRUPT)
                && DFW_RET(retval, on_interrupt(req, in->unique))){
        }

        sp<FuseRequest> intrReq = m_reqlist->getRequest(in->unique);
        if(intrReq.has()){
            {
                AutoLock _l(intrReq.get());
                intrReq->setInterrupt();
            }
            //intrReq->send_error(-EINTR);
        }

        return NULL;
    }

#if 0
    // --------------------------------------------------------------

    sp<Retval> FuseWorker::sys_readdir(
            sp<FuseRequest>& req, sp<FsNode>& node
          , const char* fullpath, sp<FuseDirCtx>& ctx)
    {
        struct stat st;
        sp<FsNode> root = req->m_nl->_findNode(1);
        ::memcpy(&st, &root->m_stat, sizeof(st));
        st.st_size = 0;
        st.st_nlink = 1;
        st.st_rdev = 0;

        AutoLock _l(&m_sfl);
        for(int k=0; k<m_sfl.size(); k++){
            sp<SysFile> sf = m_sfl.get(k);
            if(!sf.has()) continue;
            if(sf->m_bdir){
                st.st_mode = (Stat::D_IFDIR|0755);
            }else{
                st.st_mode = (Stat::D_IFREG|0644);
            }
            ctx->fill(req, sf->m_name.toChars(), &st);
        }

        return NULL;
    }

    sp<Retval> FuseWorker::sys_lookup(
            sp<FuseRequest>& req, sp<FsNode>& node
          , const char* fullpath, struct stat* st)
    {
        sp<FsNode> root = req->m_nl->_findNode(1);
        ::memcpy(st, &root->m_stat, sizeof(*st));

        st->st_size = 0;
        st->st_nlink = 0;
        st->st_rdev = 0;
        st->st_ctime = st->st_mtime = st->st_atime 
                              = (Time::currentTimeMillis()/1000);

        node->m_bsystem = true;

        if(node->m_name.equals(EXTENDS_FOLDER))
            return NULL;

        sp<SysFile> sf;
        sp<SysFile> test = new SysFile(node->m_name.toChars(), false);
        {
            AutoLock _l(&m_sfl);
            sf = m_sfl.get(test);
        }
        if(!sf.has())
            return DFW_RETVAL_NEW(DFW_E_NOENT, -ENOENT);

        if(sf->m_bdir)
            st->st_mode = (Stat::D_IFDIR|0755);
        else
            st->st_mode = (Stat::D_IFREG|0644);

        return NULL;
    }

    sp<Retval> FuseWorker::sys_open(sp<FuseRequest>& req
                    , sp<FsNode>& node
                    , const char* fullpath
                    , sp<FuseOpenCtx>& ctx)
    {
        sp<Retval> retval;

        if(ctx->m_flags & O_CREAT)
            return DFW_RETVAL_NEW(DFW_E_PERM, -EPERM);
        if(ctx->m_flags & O_EXCL)
            return DFW_RETVAL_NEW(DFW_E_PERM, -EPERM);
        if(ctx->m_flags & O_TRUNC)
            return DFW_RETVAL_NEW(DFW_E_PERM, -EPERM);

        sp<SysFile> sf;
        sp<SysFile> test = new SysFile(node->m_name.toChars(), false);
        {
            AutoLock _l(&m_sfl);
            sf = m_sfl.get(test);
        }
        if(!sf.has())
            return DFW_RETVAL_NEW(DFW_E_NOENT, -ENOENT);

        String* context = new String();
        if(node->m_name.equals("info.txt")){
            sp<ThreadManager> tm = ThreadManager::instance();
  context->appendFmt("tthread-size: %d\n", tm->size());
  context->appendFmt("tthread-ref: %d\n", tm->refcount());
  context->appendFmt("tnode-size: %d\n", req->m_nl->size());
  context->appendFmt("tnode-currentid: %ld\n", req->m_nl->currentNextid());
  context->appendFmt("tnode-generation: %d\n", req->m_nl->generation());
  context->appendFmt("request-size: %d\n", m_reqlist->size());
  context->appendFmt("request-unique: %ld\n", req->m_mount->getUnique());
  context->appendFmt("request-opcode: %d\n", req->m_mount->getLastOpcode());
  on_sys_open(req, node, fullpath, ctx, *context);
        }else if(node->m_name.equals("nodes.txt")){
  String pfpath;
  sp<FsNode> parent;
  context->appendFmt("dest-name: %s\n", fullpath);
  if(DFW_RET(retval, req->m_nl->getParentNode(parent, pfpath, node->m_parentid))){
      context->appendFmt("Not find parentid: %ld\n", node->m_parentid);
  }else{
      const char* pfullpath = pfpath.toChars();
      context->appendFmt("parent-name: %s\n", pfullpath);
      AutoLock _p(parent.get());
      int childsize = req->m_nl->childLength(parent);
      for(int k=0; k<childsize; k++){
          sp<FsNode> chd = req->m_nl->getChild(parent, k);
          context->appendFmt("p=%5d, nlookup=%ld, %s\n"
              , k
              , chd->m_nlookup
              , chd->m_name.toChars()
          );
      }
  }
        }

        sp<Object> cobj = context;
        sp<NamedObject> no = new NamedObject("context", cobj);
        if( DFW_RET(retval, ctx->insertContext(no)) ){
            return DFW_RETVAL_D(retval);
        }
        return NULL;
    }

    sp<Retval> FuseWorker::sys_read(sp<FuseRequest>& req
                    , sp<FsNode>& node
                    , const char* fullpath
                    , unsigned *out_size
                    , char* buf
                    , uint32_t size
                    , uint64_t offset, sp<FuseOpenCtx>& ctx)
    {
        *out_size = 0;
        sp<NamedObject> src = new NamedObject("context");
        sp<NamedObject> no = ctx->getContext(src);
        if(no.has()){
            sp<String> dst = no->m_object;
            if(offset>dst->length())
                return NULL;
            *out_size = dst->length() - offset;
            if(*out_size > size) *out_size = size;
            if(*out_size!=0){
                const char* dstbuf = dst->toChars();
                ::strncpy( buf, dstbuf + offset, *out_size);
            }
        }
        return NULL;
    }

    sp<Retval> FuseWorker::sys_release(sp<FuseRequest>& req
                    , sp<FsNode>& node
                    , const char* fullpath
                    , sp<FuseOpenCtx>& ctx)
    {
        return NULL;
    }
#endif

};
#endif

